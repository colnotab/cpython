// File automatically generated by Parser/asdl_c.py.

#include "Python.h"
#include "pycore_ast.h"
#define TRAVERSE(TYPE, NODE) { \
    if ((NODE)) { \
        result = find_ ## TYPE((NODE), tag, lineno, end_lineno, col_offset, end_col_offset); \
        if (result) { \
            return result; \
        } \
    } \
}

#define TRAVERSE_SEQ(TYPE, SEQ) { \
    int _i; \
    for (_i = 0; _i < asdl_seq_LEN((SEQ)); _i++) { \
        TYPE ## _ty elt = (TYPE ## _ty)asdl_seq_GET((SEQ), _i); \
        TRAVERSE(TYPE, elt); \
    } \
}
void * find_mod(mod_ty, int, int *, int *, int *, int *);
void * find_stmt(stmt_ty, int, int *, int *, int *, int *);
void * find_expr(expr_ty, int, int *, int *, int *, int *);
void * find_expr_context(expr_context_ty, int, int *, int *, int *, int *);
void * find_boolop(boolop_ty, int, int *, int *, int *, int *);
void * find_operator(operator_ty, int, int *, int *, int *, int *);
void * find_unaryop(unaryop_ty, int, int *, int *, int *, int *);
void * find_cmpop(cmpop_ty, int, int *, int *, int *, int *);
void * find_comprehension(comprehension_ty, int, int *, int *, int *, int *);
void * find_excepthandler(excepthandler_ty, int, int *, int *, int *, int *);
void * find_arguments(arguments_ty, int, int *, int *, int *, int *);
void * find_arg(arg_ty, int, int *, int *, int *, int *);
void * find_keyword(keyword_ty, int, int *, int *, int *, int *);
void * find_alias(alias_ty, int, int *, int *, int *, int *);
void * find_withitem(withitem_ty, int, int *, int *, int *, int *);
void * find_match_case(match_case_ty, int, int *, int *, int *, int *);
void * find_pattern(pattern_ty, int, int *, int *, int *, int *);
void * find_type_ignore(type_ignore_ty, int, int *, int *, int *, int *);

void *
find_mod(mod_ty node, int tag, int *lineno, int *end_lineno, int *col_offset,
         int *end_col_offset)
{
    void *result = NULL;
    switch (node->kind) {
        case Module_kind: {
            TRAVERSE_SEQ(stmt, node->v.Module.body);
            TRAVERSE_SEQ(type_ignore, node->v.Module.type_ignores);
            break;
        }
        case Interactive_kind: {
            TRAVERSE_SEQ(stmt, node->v.Interactive.body);
            break;
        }
        case Expression_kind: {
            TRAVERSE(expr, node->v.Expression.body);
            break;
        }
        case FunctionType_kind: {
            TRAVERSE_SEQ(expr, node->v.FunctionType.argtypes);
            TRAVERSE(expr, node->v.FunctionType.returns);
            break;
        }
    }
    return result;
}
void *
find_stmt(stmt_ty node, int tag, int *lineno, int *end_lineno, int *col_offset,
          int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    switch (node->kind) {
        case FunctionDef_kind: {
            TRAVERSE(arguments, node->v.FunctionDef.args);
            TRAVERSE_SEQ(stmt, node->v.FunctionDef.body);
            TRAVERSE_SEQ(expr, node->v.FunctionDef.decorator_list);
            TRAVERSE(expr, node->v.FunctionDef.returns);
            break;
        }
        case AsyncFunctionDef_kind: {
            TRAVERSE(arguments, node->v.AsyncFunctionDef.args);
            TRAVERSE_SEQ(stmt, node->v.AsyncFunctionDef.body);
            TRAVERSE_SEQ(expr, node->v.AsyncFunctionDef.decorator_list);
            TRAVERSE(expr, node->v.AsyncFunctionDef.returns);
            break;
        }
        case ClassDef_kind: {
            TRAVERSE_SEQ(expr, node->v.ClassDef.bases);
            TRAVERSE_SEQ(keyword, node->v.ClassDef.keywords);
            TRAVERSE_SEQ(stmt, node->v.ClassDef.body);
            TRAVERSE_SEQ(expr, node->v.ClassDef.decorator_list);
            break;
        }
        case Return_kind: {
            TRAVERSE(expr, node->v.Return.value);
            break;
        }
        case Delete_kind: {
            TRAVERSE_SEQ(expr, node->v.Delete.targets);
            break;
        }
        case Assign_kind: {
            TRAVERSE_SEQ(expr, node->v.Assign.targets);
            TRAVERSE(expr, node->v.Assign.value);
            break;
        }
        case AugAssign_kind: {
            TRAVERSE(expr, node->v.AugAssign.target);
            TRAVERSE(operator, node->v.AugAssign.op);
            TRAVERSE(expr, node->v.AugAssign.value);
            break;
        }
        case AnnAssign_kind: {
            TRAVERSE(expr, node->v.AnnAssign.target);
            TRAVERSE(expr, node->v.AnnAssign.annotation);
            TRAVERSE(expr, node->v.AnnAssign.value);
            break;
        }
        case For_kind: {
            TRAVERSE(expr, node->v.For.target);
            TRAVERSE(expr, node->v.For.iter);
            TRAVERSE_SEQ(stmt, node->v.For.body);
            TRAVERSE_SEQ(stmt, node->v.For.orelse);
            break;
        }
        case AsyncFor_kind: {
            TRAVERSE(expr, node->v.AsyncFor.target);
            TRAVERSE(expr, node->v.AsyncFor.iter);
            TRAVERSE_SEQ(stmt, node->v.AsyncFor.body);
            TRAVERSE_SEQ(stmt, node->v.AsyncFor.orelse);
            break;
        }
        case While_kind: {
            TRAVERSE(expr, node->v.While.test);
            TRAVERSE_SEQ(stmt, node->v.While.body);
            TRAVERSE_SEQ(stmt, node->v.While.orelse);
            break;
        }
        case If_kind: {
            TRAVERSE(expr, node->v.If.test);
            TRAVERSE_SEQ(stmt, node->v.If.body);
            TRAVERSE_SEQ(stmt, node->v.If.orelse);
            break;
        }
        case With_kind: {
            TRAVERSE_SEQ(withitem, node->v.With.items);
            TRAVERSE_SEQ(stmt, node->v.With.body);
            break;
        }
        case AsyncWith_kind: {
            TRAVERSE_SEQ(withitem, node->v.AsyncWith.items);
            TRAVERSE_SEQ(stmt, node->v.AsyncWith.body);
            break;
        }
        case Match_kind: {
            TRAVERSE(expr, node->v.Match.subject);
            TRAVERSE_SEQ(match_case, node->v.Match.cases);
            break;
        }
        case Raise_kind: {
            TRAVERSE(expr, node->v.Raise.exc);
            TRAVERSE(expr, node->v.Raise.cause);
            break;
        }
        case Try_kind: {
            TRAVERSE_SEQ(stmt, node->v.Try.body);
            TRAVERSE_SEQ(excepthandler, node->v.Try.handlers);
            TRAVERSE_SEQ(stmt, node->v.Try.orelse);
            TRAVERSE_SEQ(stmt, node->v.Try.finalbody);
            break;
        }
        case Assert_kind: {
            TRAVERSE(expr, node->v.Assert.test);
            TRAVERSE(expr, node->v.Assert.msg);
            break;
        }
        case Import_kind: {
            TRAVERSE_SEQ(alias, node->v.Import.names);
            break;
        }
        case ImportFrom_kind: {
            TRAVERSE_SEQ(alias, node->v.ImportFrom.names);
            break;
        }
        case Global_kind: {
            break;
        }
        case Nonlocal_kind: {
            break;
        }
        case Expr_kind: {
            TRAVERSE(expr, node->v.Expr.value);
            break;
        }
        case Pass_kind: {
            break;
        }
        case Break_kind: {
            break;
        }
        case Continue_kind: {
            break;
        }
    }
    return result;
}
void *
find_expr(expr_ty node, int tag, int *lineno, int *end_lineno, int *col_offset,
          int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    switch (node->kind) {
        case BoolOp_kind: {
            TRAVERSE(boolop, node->v.BoolOp.op);
            TRAVERSE_SEQ(expr, node->v.BoolOp.values);
            break;
        }
        case NamedExpr_kind: {
            TRAVERSE(expr, node->v.NamedExpr.target);
            TRAVERSE(expr, node->v.NamedExpr.value);
            break;
        }
        case BinOp_kind: {
            TRAVERSE(expr, node->v.BinOp.left);
            TRAVERSE(operator, node->v.BinOp.op);
            TRAVERSE(expr, node->v.BinOp.right);
            break;
        }
        case UnaryOp_kind: {
            TRAVERSE(unaryop, node->v.UnaryOp.op);
            TRAVERSE(expr, node->v.UnaryOp.operand);
            break;
        }
        case Lambda_kind: {
            TRAVERSE(arguments, node->v.Lambda.args);
            TRAVERSE(expr, node->v.Lambda.body);
            break;
        }
        case IfExp_kind: {
            TRAVERSE(expr, node->v.IfExp.test);
            TRAVERSE(expr, node->v.IfExp.body);
            TRAVERSE(expr, node->v.IfExp.orelse);
            break;
        }
        case Dict_kind: {
            TRAVERSE_SEQ(expr, node->v.Dict.keys);
            TRAVERSE_SEQ(expr, node->v.Dict.values);
            break;
        }
        case Set_kind: {
            TRAVERSE_SEQ(expr, node->v.Set.elts);
            break;
        }
        case ListComp_kind: {
            TRAVERSE(expr, node->v.ListComp.elt);
            TRAVERSE_SEQ(comprehension, node->v.ListComp.generators);
            break;
        }
        case SetComp_kind: {
            TRAVERSE(expr, node->v.SetComp.elt);
            TRAVERSE_SEQ(comprehension, node->v.SetComp.generators);
            break;
        }
        case DictComp_kind: {
            TRAVERSE(expr, node->v.DictComp.key);
            TRAVERSE(expr, node->v.DictComp.value);
            TRAVERSE_SEQ(comprehension, node->v.DictComp.generators);
            break;
        }
        case GeneratorExp_kind: {
            TRAVERSE(expr, node->v.GeneratorExp.elt);
            TRAVERSE_SEQ(comprehension, node->v.GeneratorExp.generators);
            break;
        }
        case Await_kind: {
            TRAVERSE(expr, node->v.Await.value);
            break;
        }
        case Yield_kind: {
            TRAVERSE(expr, node->v.Yield.value);
            break;
        }
        case YieldFrom_kind: {
            TRAVERSE(expr, node->v.YieldFrom.value);
            break;
        }
        case Compare_kind: {
            TRAVERSE(expr, node->v.Compare.left);
            TRAVERSE_SEQ(cmpop, node->v.Compare.ops);
            TRAVERSE_SEQ(expr, node->v.Compare.comparators);
            break;
        }
        case Call_kind: {
            TRAVERSE(expr, node->v.Call.func);
            TRAVERSE_SEQ(expr, node->v.Call.args);
            TRAVERSE_SEQ(keyword, node->v.Call.keywords);
            break;
        }
        case FormattedValue_kind: {
            TRAVERSE(expr, node->v.FormattedValue.value);
            TRAVERSE(expr, node->v.FormattedValue.format_spec);
            break;
        }
        case JoinedStr_kind: {
            TRAVERSE_SEQ(expr, node->v.JoinedStr.values);
            break;
        }
        case Constant_kind: {
            break;
        }
        case Attribute_kind: {
            TRAVERSE(expr, node->v.Attribute.value);
            TRAVERSE(expr_context, node->v.Attribute.ctx);
            break;
        }
        case Subscript_kind: {
            TRAVERSE(expr, node->v.Subscript.value);
            TRAVERSE(expr, node->v.Subscript.slice);
            TRAVERSE(expr_context, node->v.Subscript.ctx);
            break;
        }
        case Starred_kind: {
            TRAVERSE(expr, node->v.Starred.value);
            TRAVERSE(expr_context, node->v.Starred.ctx);
            break;
        }
        case Name_kind: {
            TRAVERSE(expr_context, node->v.Name.ctx);
            break;
        }
        case List_kind: {
            TRAVERSE_SEQ(expr, node->v.List.elts);
            TRAVERSE(expr_context, node->v.List.ctx);
            break;
        }
        case Tuple_kind: {
            TRAVERSE_SEQ(expr, node->v.Tuple.elts);
            TRAVERSE(expr_context, node->v.Tuple.ctx);
            break;
        }
        case Slice_kind: {
            TRAVERSE(expr, node->v.Slice.lower);
            TRAVERSE(expr, node->v.Slice.upper);
            TRAVERSE(expr, node->v.Slice.step);
            break;
        }
    }
    return result;
}
void *
find_expr_context(expr_context_ty node, int tag, int *lineno, int *end_lineno,
                  int *col_offset, int *end_col_offset)
{
    void *result = NULL;
    return result;
}
void *
find_boolop(boolop_ty node, int tag, int *lineno, int *end_lineno, int
            *col_offset, int *end_col_offset)
{
    void *result = NULL;
    return result;
}
void *
find_operator(operator_ty node, int tag, int *lineno, int *end_lineno, int
              *col_offset, int *end_col_offset)
{
    void *result = NULL;
    return result;
}
void *
find_unaryop(unaryop_ty node, int tag, int *lineno, int *end_lineno, int
             *col_offset, int *end_col_offset)
{
    void *result = NULL;
    return result;
}
void *
find_cmpop(cmpop_ty node, int tag, int *lineno, int *end_lineno, int
           *col_offset, int *end_col_offset)
{
    void *result = NULL;
    return result;
}
void *
find_comprehension(comprehension_ty node, int tag, int *lineno, int
                   *end_lineno, int *col_offset, int *end_col_offset)
{
    void *result = NULL;
    TRAVERSE(expr, node->target);
    TRAVERSE(expr, node->iter);
    TRAVERSE_SEQ(expr, node->ifs);
    return result;
}
void *
find_excepthandler(excepthandler_ty node, int tag, int *lineno, int
                   *end_lineno, int *col_offset, int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    switch (node->kind) {
        case ExceptHandler_kind: {
            TRAVERSE(expr, node->v.ExceptHandler.type);
            TRAVERSE_SEQ(stmt, node->v.ExceptHandler.body);
            break;
        }
    }
    return result;
}
void *
find_arguments(arguments_ty node, int tag, int *lineno, int *end_lineno, int
               *col_offset, int *end_col_offset)
{
    void *result = NULL;
    TRAVERSE_SEQ(arg, node->posonlyargs);
    TRAVERSE_SEQ(arg, node->args);
    TRAVERSE(arg, node->vararg);
    TRAVERSE_SEQ(arg, node->kwonlyargs);
    TRAVERSE_SEQ(expr, node->kw_defaults);
    TRAVERSE(arg, node->kwarg);
    TRAVERSE_SEQ(expr, node->defaults);
    return result;
}
void *
find_arg(arg_ty node, int tag, int *lineno, int *end_lineno, int *col_offset,
         int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    TRAVERSE(expr, node->annotation);
    return result;
}
void *
find_keyword(keyword_ty node, int tag, int *lineno, int *end_lineno, int
             *col_offset, int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    TRAVERSE(expr, node->value);
    return result;
}
void *
find_alias(alias_ty node, int tag, int *lineno, int *end_lineno, int
           *col_offset, int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    return result;
}
void *
find_withitem(withitem_ty node, int tag, int *lineno, int *end_lineno, int
              *col_offset, int *end_col_offset)
{
    void *result = NULL;
    TRAVERSE(expr, node->context_expr);
    TRAVERSE(expr, node->optional_vars);
    return result;
}
void *
find_match_case(match_case_ty node, int tag, int *lineno, int *end_lineno, int
                *col_offset, int *end_col_offset)
{
    void *result = NULL;
    TRAVERSE(pattern, node->pattern);
    TRAVERSE(expr, node->guard);
    TRAVERSE_SEQ(stmt, node->body);
    return result;
}
void *
find_pattern(pattern_ty node, int tag, int *lineno, int *end_lineno, int
             *col_offset, int *end_col_offset)
{
    void *result = NULL;
    if (node->node_id == tag) {
        *lineno = node->lineno;
        *end_lineno = node->end_lineno;
        *col_offset = node->col_offset;
        *end_col_offset = node->end_col_offset;
        return node;
    }
    switch (node->kind) {
        case MatchValue_kind: {
            TRAVERSE(expr, node->v.MatchValue.value);
            break;
        }
        case MatchSingleton_kind: {
            break;
        }
        case MatchSequence_kind: {
            TRAVERSE_SEQ(pattern, node->v.MatchSequence.patterns);
            break;
        }
        case MatchMapping_kind: {
            TRAVERSE_SEQ(expr, node->v.MatchMapping.keys);
            TRAVERSE_SEQ(pattern, node->v.MatchMapping.patterns);
            break;
        }
        case MatchClass_kind: {
            TRAVERSE(expr, node->v.MatchClass.cls);
            TRAVERSE_SEQ(pattern, node->v.MatchClass.patterns);
            TRAVERSE_SEQ(pattern, node->v.MatchClass.kwd_patterns);
            break;
        }
        case MatchStar_kind: {
            break;
        }
        case MatchAs_kind: {
            TRAVERSE(pattern, node->v.MatchAs.pattern);
            break;
        }
        case MatchOr_kind: {
            TRAVERSE_SEQ(pattern, node->v.MatchOr.patterns);
            break;
        }
    }
    return result;
}
void *
find_type_ignore(type_ignore_ty node, int tag, int *lineno, int *end_lineno,
                 int *col_offset, int *end_col_offset)
{
    void *result = NULL;
    switch (node->kind) {
        case TypeIgnore_kind: {
            break;
        }
    }
    return result;
}

void *
_PyAST_FindTaggedNode(mod_ty tree, int tag, int *lineno,
                      int *end_lineno, int *col_offset,
                      int *end_col_offset)
{
    return find_mod(tree, tag, lineno, end_lineno,
                    col_offset, end_col_offset);
}
